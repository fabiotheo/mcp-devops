#!/usr/bin/env node
// ~/.mcp-terminal/mcp-assistant.js

import { Anthropic } from '@anthropic-ai/sdk';
import SystemDetector from './system_detector.js';
import fs from 'fs/promises';
import { existsSync, readFileSync, writeFileSync } from 'fs'; // Keep for sync ops if any, or specific needs
import path from 'path';
import { execSync, spawn } from 'child_process';
import ModelFactory from './ai_models/model_factory.js';
import readline from 'readline';
import os from 'os'; // For tmpdir and EOL

const CONFIG_PATH = path.join(process.env.HOME, '.mcp-terminal/config.json');
const HISTORY_PATH = path.join(process.env.HOME, '.mcp-terminal/command-history.json');

class MCPAssistant {
    constructor() {
        this.configPath = CONFIG_PATH;
        this.systemDetector = new SystemDetector();
        this.aiModel = null;
        this.config = {}; // Initialize config
        // loadConfig is called asynchronously, so ensure it's handled if methods depend on it immediately
    }

    async loadConfig() {
        try {
            if (!existsSync(this.configPath)) {
                console.error(`‚ùå Arquivo de configura√ß√£o n√£o encontrado em ${this.configPath}`);
                console.error('Execute: mcp-setup --configure');
                process.exit(1);
            }
            const configData = await fs.readFile(this.configPath, 'utf8');
            this.config = JSON.parse(configData);

            try {
                this.aiModel = await ModelFactory.createModel(this.config);
            } catch (error) {
                console.warn(`‚ö†Ô∏è  Aviso ao inicializar modelo de IA via ModelFactory: ${error.message}`);
                if (this.config.anthropic_api_key) {
                    console.log('üîÅ Tentando fallback para Anthropic SDK direto...');
                    this.anthropic = new Anthropic({
                        apiKey: this.config.anthropic_api_key,
                    });
                    // Mark that we are using fallback
                    this.usingFallbackAI = true;
                } else {
                    console.error('‚ùå Nenhuma API key da Anthropic configurada para fallback.');
                    throw new Error('Falha ao inicializar o modelo de IA e sem fallback configurado.');
                }
            }

        } catch (error) {
            console.error('‚ùå Erro cr√≠tico ao carregar configura√ß√£o ou inicializar IA:', error.message);
            console.error('Verifique sua configura√ß√£o ou execute: mcp-setup --configure');
            process.exit(1);
        }
    }

    async askCommand(question) {
        if (!this.aiModel && !this.anthropic) {
            // This might happen if loadConfig hasn't completed or failed critically
            await this.loadConfig(); // Ensure config is loaded
        }

        try {
            const systemContext = this.systemDetector.getSystemContext();
            const currentDir = process.cwd();
            const dirInfo = await this.getCurrentDirectoryInfo();

            if (this.aiModel && !this.usingFallbackAI) {
                return await this.aiModel.askCommand(question, {
                    ...systemContext,
                    currentDir,
                    dirInfo,
                });
            }

            // Fallback para o sistema antigo (Claude direto via Anthropic SDK)
            if (!this.anthropic) {
                return '‚ùå Erro: Cliente Anthropic (fallback) n√£o inicializado. Verifique sua API key.';
            }

            const prompt = `Voc√™ √© um assistente especializado em Linux/Unix que ajuda usu√°rios a encontrar o comando correto para suas tarefas.

INFORMA√á√ïES DO SISTEMA:
- OS: ${systemContext.os}
- Distribui√ß√£o: ${systemContext.distro}
- Vers√£o: ${systemContext.version}
- Package Manager: ${systemContext.packageManager}
- Shell: ${systemContext.shell}
- Arquitetura: ${systemContext.architecture}
- Kernel: ${systemContext.kernel}
- Capacidades: ${systemContext.capabilities.join(', ') || 'N/A'}

DIRET√ìRIO ATUAL: ${currentDir}
${dirInfo}

COMANDOS DISPON√çVEIS NESTE SISTEMA (amostra ou relevantes, se aplic√°vel):
${systemContext.commands && systemContext.commands.length > 0 ? JSON.stringify(systemContext.commands.slice(0, 20), null, 2) + (systemContext.commands.length > 20 ? "\n(e mais...)" : "") : "N√£o especificado"}

PERGUNTA DO USU√ÅRIO: ${question}

INSTRU√á√ïES:
1. Analise a pergunta considerando o sistema espec√≠fico do usu√°rio.
2. Forne√ßa o comando exato para a distribui√ß√£o/sistema detectado.
3. Explique brevemente o que o comando faz.
4. Se houver varia√ß√µes por distribui√ß√£o, mencione isso.
5. Inclua op√ß√µes √∫teis do comando.
6. Se apropriado, sugira comandos relacionados.

FORMATO DA RESPOSTA (use este formato estritamente):
üîß COMANDO:
\`\`\`bash
comando exato aqui
\`\`\`

üìù EXPLICA√á√ÉO:
[Explica√ß√£o clara do que faz]

üí° OP√á√ïES √öTEIS:
[Varia√ß√µes ou op√ß√µes importantes]

‚ö†Ô∏è OBSERVA√á√ïES:
[Avisos ou considera√ß√µes especiais]

Responda de forma direta e pr√°tica. Se o comando for multi-linha, coloque cada parte em uma nova linha dentro do bloco de c√≥digo bash.`;

            const modelToUse = this.config.claude_model || this.config.model || "claude-3-sonnet-20240229"; // Exemplo de nome de modelo v√°lido
            const response = await this.anthropic.messages.create({
                model: modelToUse,
                max_tokens: 2000,
                messages: [{ role: 'user', content: prompt }],
            });

            return response.content[0].text;
        } catch (error) {
            console.error('‚ùå Erro ao consultar assistente:', error.message);
            return '‚ùå Erro ao conectar com o assistente. Verifique sua configura√ß√£o e a API key.';
        }
    }

    async getCurrentDirectoryInfo() {
        try {
            // Lista alguns arquivos e diret√≥rios do diret√≥rio atual
            let files = [];
            let dirs = [];
            try {
                const entries = await fs.readdir('.', { withFileTypes: true });
                files = entries.filter(e => e.isFile()).map(e => e.name).slice(0, 10); // Show more
                dirs = entries.filter(e => e.isDirectory()).map(e => e.name).slice(0, 5);
            } catch (e) {
                // Silently ignore if can't read dir, e.g. permissions
            }

            let projectType = [];
            // Check for common project files
            const projectFiles = {
                'Node.js': 'package.json',
                'Rust': 'Cargo.toml',
                'Go': 'go.mod',
                'Python': 'requirements.txt',
                'Make': 'Makefile',
                'Git Repo': '.git', // .git is a directory
            };

            for (const [type, fileOrDir] of Object.entries(projectFiles)) {
                try {
                    await fs.access(fileOrDir); // Checks existence
                    projectType.push(type);
                } catch { /* File/dir not found */ }
            }

            return `
INFORMA√á√ïES DO DIRET√ìRIO:
- Tipo de projeto detectado: ${projectType.length > 0 ? projectType.join(', ') : 'Gen√©rico'}
- Primeiros arquivos: ${files.join(', ') || 'Nenhum vis√≠vel'}
- Primeiros diret√≥rios: ${dirs.join(', ') || 'Nenhum vis√≠vel'}`;

        } catch (error) {
            console.warn(`‚ö†Ô∏è  N√£o foi poss√≠vel obter informa√ß√µes detalhadas do diret√≥rio: ${error.message}`);
            return 'INFORMA√á√ïES DO DIRET√ìRIO: N√£o foi poss√≠vel carregar.';
        }
    }

    async saveCommandHistory(question, command) {
        try {
            let history = [];
            if (existsSync(HISTORY_PATH)) {
                const content = await fs.readFile(HISTORY_PATH, 'utf8');
                history = JSON.parse(content);
            }

            history.unshift({
                timestamp: new Date().toISOString(),
                question,
                command,
                system: this.systemDetector.getSystemContext().distro || this.systemDetector.getSystemContext().os, // Simpler system info
                provider: (this.aiModel && !this.usingFallbackAI) ? this.aiModel.getProviderName() : 'Anthropic (Fallback)',
            });

            history = history.slice(0, 100); // Manter apenas os √∫ltimos 100
            await fs.writeFile(HISTORY_PATH, JSON.stringify(history, null, 2));
        } catch (error) {
            console.error('‚ùå Erro ao salvar hist√≥rico:', error.message);
        }
    }

    getProviderInfo() {
        if (this.aiModel && !this.usingFallbackAI) {
            return {
                provider: this.aiModel.getProviderName(),
                model: this.aiModel.getModelName(),
            };
        }
        return {
            provider: 'Anthropic (Fallback)',
            model: this.config.claude_model || this.config.model || "claude-3-sonnet-20240229",
        };
    }

    async listDirectory(dirPath = '.') {
        try {
            const absolutePath = path.resolve(dirPath);
            const entries = await fs.readdir(absolutePath, { withFileTypes: true });
            const items = entries.map(entry => ({
                name: entry.name,
                type: entry.isDirectory() ? 'directory' : 'file',
                path: path.join(absolutePath, entry.name),
            })).sort((a,b) => { // Sort directories first, then files, then alphabetically
                if (a.type === b.type) return a.name.localeCompare(b.name);
                return a.type === 'directory' ? -1 : 1;
            });

            return {
                currentPath: absolutePath,
                parent: path.dirname(absolutePath),
                items,
            };
        } catch (error) {
            console.error(`‚ùå Erro ao listar diret√≥rio ${dirPath}:`, error.message);
            throw error; // Re-throw para ser tratado pelo chamador
        }
    }

    async readFile(filePath) {
        try {
            const absolutePath = path.resolve(filePath);
            return await fs.readFile(absolutePath, 'utf8');
        } catch (error) {
            console.error(`‚ùå Erro ao ler arquivo ${filePath}:`, error.message);
            throw error;
        }
    }

    async editFile(filePath) {
        const absolutePath = path.resolve(filePath);
        let currentContent = '';
        try {
            currentContent = await fs.readFile(absolutePath, 'utf8');
        } catch (error) {
            if (error.code === 'ENOENT') {
                console.log(`üìù Arquivo n√£o existe. Ser√° criado: ${absolutePath}`);
            } else {
                console.error(`‚ùå Erro ao ler arquivo para edi√ß√£o ${absolutePath}:`, error.message);
                throw error;
            }
        }

        const tempDir = os.tmpdir();
        const tempFileName = `mcp-edit-${Date.now()}-${path.basename(absolutePath)}`;
        const tempFilePath = path.join(tempDir, tempFileName);

        try {
            await fs.writeFile(tempFilePath, currentContent, 'utf8');

            const editor = process.env.EDITOR || process.env.VISUAL || 'nano'; // Default to nano
            console.log(`\n‚úèÔ∏è  Abrindo ${absolutePath} com ${editor}... (Salve e feche o editor para continuar)`);

            await new Promise((resolve, reject) => {
                const editorProcess = spawn(editor, [tempFilePath], { stdio: 'inherit' });
                editorProcess.on('exit', (code) => {
                    if (code === 0) {
                        resolve();
                    } else {
                        reject(new Error(`Editor ${editor} saiu com c√≥digo de erro ${code}.`));
                    }
                });
                editorProcess.on('error', (err) => {
                    reject(new Error(`Falha ao iniciar o editor ${editor}: ${err.message}`));
                });
            });

            const newContent = await fs.readFile(tempFilePath, 'utf8');
            await fs.writeFile(absolutePath, newContent, 'utf8');
            console.log(`\n‚úÖ Arquivo salvo com sucesso: ${absolutePath}`);
            return true;

        } catch (error) {
            console.error(`‚ùå Erro durante a edi√ß√£o do arquivo ${absolutePath}:`, error.message);
            throw error;
        } finally {
            // Clean up temporary file
            try {
                await fs.unlink(tempFilePath);
            } catch (e) {
                // Ignore errors during temp file cleanup, but log them
                console.warn(`‚ö†Ô∏è  N√£o foi poss√≠vel remover o arquivo tempor√°rio: ${tempFilePath}`, e.message);
            }
        }
    }


    async removeItem(itemPath) {
        try {
            const absolutePath = path.resolve(itemPath);
            const stats = await fs.stat(absolutePath);

            if (stats.isDirectory()) {
                await fs.rm(absolutePath, { recursive: true, force: true });
                return { success: true, type: 'directory' };
            } else {
                await fs.unlink(absolutePath);
                return { success: true, type: 'file' };
            }
        } catch (error) {
            console.error(`‚ùå Erro ao remover item ${itemPath}:`, error.message);
            throw error;
        }
    }

    async getItemInfo(itemPath) {
        try {
            const absolutePath = path.resolve(itemPath);
            const stats = await fs.stat(absolutePath);
            const info = {
                path: absolutePath,
                name: path.basename(absolutePath),
                size: stats.size,
                created: stats.birthtime,
                modified: stats.mtime,
                accessed: stats.atime,
                isDirectory: stats.isDirectory(),
                isFile: stats.isFile(),
                permissions: (stats.mode & 0o777).toString(8), // More reliable permission string
            };

            if (info.isDirectory) {
                try {
                    const entries = await fs.readdir(absolutePath);
                    info.contents = entries.length;
                } catch (e) {
                    info.contents = 'N/A';
                    info.error = `Sem permiss√£o para ler conte√∫do de ${absolutePath}`;
                }
            }
            return info;
        } catch (error) {
            console.error(`‚ùå Erro ao obter informa√ß√µes de ${itemPath}:`, error.message);
            throw error;
        }
    }
}

// CLI
async function main() {
    const args = process.argv.slice(2);

    if (args.length === 0 || args[0] === '--help' || args[0] === '-h') {
        console.log(`
ü§ñ MCP Terminal Assistant

USO:
  ask "sua pergunta sobre comando linux"
  ask --history                    # Ver hist√≥rico dos √∫ltimos 10 comandos
  ask --system-info                # Informa√ß√µes do sistema detectadas
  ask --provider-info              # Informa√ß√µes do provedor de IA atual

OPERA√á√ïES DE ARQUIVOS:
  ask --list [caminho]             # Listar conte√∫do do diret√≥rio (padr√£o: .)
  ask --read <arquivo>             # Ler conte√∫do do arquivo
  ask --edit <arquivo>             # Editar arquivo usando $EDITOR (ou nano)
  ask --delete <caminho>           # Remover arquivo ou diret√≥rio (com confirma√ß√£o)
  ask --info <caminho>             # Informa√ß√µes detalhadas sobre arquivo/diret√≥rio

EXEMPLOS:
  ask "como listar arquivos por data de modifica√ß√£o"
  ask "encontrar arquivos maiores que 1GB em /var/log"
  ask --list /etc
  ask --read ~/.bashrc
  ask --edit ./meu_script.sh
        `);
        process.exit(0);
    }

    const assistant = new MCPAssistant();
    await assistant.loadConfig(); // Ensure config is loaded before proceeding

    const command = args[0].toLowerCase();
    const commandArg = args[1];

    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
    });

    const askConfirmation = (prompt) => {
        return new Promise((resolve) => {
            rl.question(prompt, (answer) => {
                resolve(answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes');
            });
        });
    };

    try {
        switch (command) {
            case '--history':
                try {
                    const historyData = await fs.readFile(HISTORY_PATH, 'utf8');
                    const history = JSON.parse(historyData);
                    console.log('\nüìö √öltimos comandos sugeridos (at√© 10 mais recentes):\n');
                    history.slice(0, 10).forEach((entry, i) => {
                        console.log(`${i + 1}. Pergunta: ${entry.question}`);
                        console.log(`   üíª Comando: ${entry.command}`);
                        console.log(`   üìÖ Data: ${new Date(entry.timestamp).toLocaleString()}`);
                        if (entry.provider) console.log(`   ü§ñ Provedor: ${entry.provider}`);
                        if (entry.system) console.log(`   üñ•Ô∏è  Sistema: ${entry.system}`);
                        console.log('');
                    });
                } catch (err) {
                    if (err.code === 'ENOENT') console.log('Nenhum hist√≥rico encontrado.');
                    else console.error('‚ùå Erro ao ler hist√≥rico:', err.message);
                }
                break;

            case '--system-info':
                console.log('\nüñ•Ô∏è  Informa√ß√µes do Sistema Detectadas:\n');
                console.log(JSON.stringify(assistant.systemDetector.getSystemContext(), null, 2));
                break;

            case '--provider-info':
                const providerInfo = assistant.getProviderInfo();
                console.log('\nü§ñ Provedor de IA Configurado:\n');
                console.log(`   Provedor: ${providerInfo.provider}`);
                console.log(`   Modelo: ${providerInfo.model}`);
                console.log('\nPara alterar, edite seu config.json ou execute: mcp-setup --configure-model');
                break;

            case '--list':
            case '-l':
                const dirPath = commandArg || '.';
                const listing = await assistant.listDirectory(dirPath);
                console.log(`\nüìÇ Conte√∫do de: ${listing.currentPath}\n`);
                console.log(`   ../ (${path.basename(listing.parent)})`); // Parent directory
                listing.items.forEach(item => {
                    console.log(`   ${item.type === 'directory' ? 'üìÅ' : 'üìÑ'} ${item.name}${item.type === 'directory' ? '/' : ''}`);
                });
                console.log(`\nTotal: ${listing.items.length} itens`);
                break;

            case '--read':
            case '-r':
                if (!commandArg) throw new Error('Caminho do arquivo n√£o especificado para --read.');
                const content = await assistant.readFile(commandArg);
                console.log(`\nüìÑ Conte√∫do de: ${path.resolve(commandArg)}\n${'-'.repeat(50)}\n${content}\n${'-'.repeat(50)}`);
                break;

            case '--edit':
            case '-e':
                if (!commandArg) throw new Error('Caminho do arquivo n√£o especificado para --edit.');
                await assistant.editFile(commandArg);
                break;

            case '--delete':
            case '-d':
                if (!commandArg) throw new Error('Caminho n√£o especificado para --delete.');
                const itemInfoForDelete = await assistant.getItemInfo(commandArg);
                const itemType = itemInfoForDelete.isDirectory ? 'diret√≥rio' : 'arquivo';
                console.log(`\n‚ö†Ô∏è  Voc√™ est√° prestes a excluir o ${itemType}: ${itemInfoForDelete.path}`);
                if (itemInfoForDelete.isDirectory && itemInfoForDelete.contents > 0) {
                    console.log(`Este diret√≥rio cont√©m ${itemInfoForDelete.contents} item(ns) que tamb√©m ser√£o exclu√≠dos.`);
                }
                const confirmedDelete = await askConfirmation('Tem certeza que deseja excluir? (y/N): ');
                if (confirmedDelete) {
                    await assistant.removeItem(commandArg);
                    console.log(`\n‚úÖ ${itemType.charAt(0).toUpperCase() + itemType.slice(1)} removido com sucesso.`);
                } else {
                    console.log('Opera√ß√£o cancelada.');
                }
                break;

            case '--info':
            case '-i':
                if (!commandArg) throw new Error('Caminho n√£o especificado para --info.');
                const info = await assistant.getItemInfo(commandArg);
                console.log(`\nüìä Informa√ß√µes de: ${info.path}\n`);
                Object.entries(info).forEach(([key, value]) => {
                    if (value instanceof Date) value = value.toLocaleString();
                    if (key === 'error' && value) console.log(`   ‚ùó ${key.charAt(0).toUpperCase() + key.slice(1)}: ${value}`);
                    else if (key !== 'error') console.log(`   ${key.charAt(0).toUpperCase() + key.slice(1)}: ${value}`);
                });
                break;

            default: // Assume it's a question for the AI
                const question = args.join(' ');
                console.log('\nü§î Analisando sua pergunta com a IA...\n');
                const response = await assistant.askCommand(question);
                console.log(response);

                // Extract command using a more specific regex for the ```bash ... ``` block or the `COMANDO: \`...\`` format
                let extractedCommand = null;
                const bashBlockMatch = response.match(/```bash\s*([\s\S]+?)\s*```/m);
                if (bashBlockMatch && bashBlockMatch[1]) {
                    extractedCommand = bashBlockMatch[1].trim();
                } else {
                    const legacyCommandMatch = response.match(/üîß COMANDO:\s*`([^`]+)`/m);
                    if (legacyCommandMatch && legacyCommandMatch[1]) {
                        extractedCommand = legacyCommandMatch[1].trim();
                    }
                }

                if (extractedCommand) {
                    // Sanitize command a bit (remove potential leading ./ or bash )
                    extractedCommand = extractedCommand.replace(/^(\.\/|bash\s+-c\s+['"]|bash\s+)/, '').replace(/['"]$/, '');

                    await assistant.saveCommandHistory(question, extractedCommand);
                    const confirmedExecute = await askConfirmation(`\n‚ùì Deseja executar o comando sugerido: \`${extractedCommand}\` ? (y/N): `);
                    if (confirmedExecute) {
                        console.log(`\n‚ñ∂Ô∏è  Executando: ${extractedCommand}\n`);
                        try {
                            execSync(extractedCommand, { stdio: 'inherit' });
                        } catch (execError) {
                            console.error(`\n‚ùå Erro ao executar comando: ${execError.message}`);
                            // execSync throws on non-zero exit, which is often not an "error" in shell sense
                            // but rather the command finished with a specific status.
                            // stderr is already inherited, so specific error details from the command should be visible.
                        }
                    } else {
                        console.log('Comando n√£o executado.');
                    }
                } else {
                    console.log('\n‚ÑπÔ∏è N√£o foi poss√≠vel extrair um comando execut√°vel da resposta.');
                }
                break;
        }
    } catch (error) {
        console.error(`\n‚ùå Erro inesperado na opera√ß√£o: ${error.message}`);
        // console.error(error.stack); // Uncomment for more detailed debug info
        process.exitCode = 1; // Set exit code to indicate failure
    } finally {
        rl.close();
    }
}

// Ensure main is called only when script is executed directly
if (import.meta.url.startsWith('file:') && process.argv[1] === import.meta.url.substring('file:'.length)) {
    main().catch(err => {
        console.error("‚ùå Falha cr√≠tica no script:", err);
        process.exit(1);
    });
}

export default MCPAssistant;
